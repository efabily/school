<?php


/**
 * Skeleton subclass for performing query and update operations on the 'sch_grade' table.
 *
 *
 *
 * This class was autogenerated by Propel 1.4.2 on:
 *
 * Wed Sep 12 01:53:16 2012
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model.student
 */
class GradePeer extends BaseGradePeer {


   public static function getActiveGrade($timetable_id = null)
   {
      $criteria = new Criteria();

      if($timetable_id)
      {
	 $criteria->add(self::TIMETABLE_ID, $timetable_id);
      }

      $criteria->add(self::ID_STATE, 2);// Activos

//      $criteria->addGroupByColumn(self::ID);

//      $criteria->addAscendingOrderByColumn(CursoPeer::NAME);

      return self::doSelect($criteria);
   }


   public static function getArrCurso($timetable_id = null)
   {
      $array_nivel = array();

      $grades = self::getActiveGrade($timetable_id);

      foreach ($grades as $grade)
      {
	 if(!isset($array_nivel[$grade->getDegree()->getName()]))
	 {
	    $array_nivel[$grade->getDegree()->getName()] = array();
	 }

	 $array_nivel[$grade->getDegree()->getName()][$grade->getId()]= $grade->getCurso()->getName().' ('.$grade->getParalelo()->getName().')';

      }

      return $array_nivel;
   }



   public static function getArrParalelo($curso_id = null)
   {
//      $array_paralelo = array(
//	'a' => 'A', 'b' => 'B',
//	'c' => 'C', 'd' => 'D',
//	'e' => 'E', 'f' => 'F',
//	'g' => 'G', 'h' => 'H',
//	'i' => 'I', 'j' => 'J',
//	'k' => 'K', 'l' => 'L'
//      );

      $array_paralelo = array();

      $criteria = new Criteria();
      $criteria->addJoin(self::PARALELO_ID, ParaleloPeer::ID);

      $criteria->add(self::ID_STATE, 2);// Activos

      if($curso_id)
      {
	 $criteria->add(self::CURSO_ID, $curso_id);
      }

      $criteria->addGroupByColumn(ParaleloPeer::ID);

      $grades = self::doSelect($criteria);

      foreach ($grades as $grade)
      {
	 if(!isset($array_paralelo[$grade->getParaleloId()]))
	 {
	    $array_paralelo[$grade->getParaleloId()] = $grade->getParalelo()->getName();
	 }
      }

      return $array_paralelo;
   }


   public static function getArrTimeTable($curso_id = null)
   {

      // $array_turno = array('1' => 'M', '2' => 'T', '3' => 'N');
      $array_turno = array();

      $criteria = new Criteria();

      $criteria->addJoin(self::TIMETABLE_ID, TimetablePeer::ID);

      $criteria->add(self::ID_STATE, 2);// Activos

      $criteria->addGroupByColumn(TimetablePeer::ID);

      if($curso_id)
      {
	 $criteria->add(self::CURSO_ID, $curso_id);
      }

      $grades = self::doSelect($criteria);

      foreach ($grades as $grade)
      {
	 if(!isset($array_turno[$grade->getTimetableId()]))
	 {
	    $array_turno[$grade->getTimetableId()] = $grade->getTimetable()->getName();
	 }
      }

      return $array_turno;
   }


   public static function getActiveGradeReport($id_state = null, $timetable_id = null, $degree_id = null, $curso_id = null)
   {
      $criteria = new Criteria();

      if($id_state)
      {
	 $criteria->add(self::ID_STATE, $id_state);// Activos
      }

      if($timetable_id)
      {
	 $criteria->add(self::TIMETABLE_ID, $timetable_id);// TURNO
      }

      if($degree_id)
      {
	 $criteria->add(self::DEGREE_ID, $degree_id);// CICLO
      }

      if($curso_id)
      {
	 $criteria->add(self::CURSO_ID, $curso_id);// CURSO
      }


      $criteria->addGroupByColumn(self::ID);

      return self::doSelect($criteria);
   }


   public static function getGradeReporteIngresoDia($period_id, $account_number, $from_date, $to_date)
   {
      $criteria = new Criteria();

      $criteria->addJoin(self::ID, ContractGradePeer::GRADE_ID);
      $criteria->addJoin(ContractGradePeer::CONTRACT_ID, ContractPeer::ID);
      $criteria->addJoin(ContractPeer::ID, AccountPeer::CONTRACT_ID);

      $criteria->add(AccountPeer::NUMBER, $account_number);
      // $criteria->add(ContractPeer::PERIOD_ID, $period_id);

      $criteria->addJoin(AccountPeer::ID, SaleAccountPeer::ACCOUNT_ID);

      $criteria->addJoin(SaleAccountPeer::SALES_ID, SalesPeer::ID);
      $criteria->addJoin(SalesPeer::ID, SalesDepositPeer::SALES_ID);
      $criteria->addJoin(SalesDepositPeer::DEPOSIT_ID, DepositPeer::ID);
      $criteria->addJoin(DepositPeer::ID, MovementCashboxDepositPeer::DEPOSIT_ID);
      $criteria->addJoin(MovementCashboxDepositPeer::MOVEMENT_CASHBOX_ID, MovementCashboxReceiptPeer::MOVEMENT_CASHBOX_ID);
      $criteria->addJoin(MovementCashboxReceiptPeer::RECEIPT_ID, ReceiptPeer::ID);
      $criteria->addJoin(ReceiptPeer::NIGHT_AUDIT_ID, NightAuditPeer::ID);

      $criteria->add(NightAuditPeer::DATE, $from_date, Criteria::GREATER_EQUAL);
      $criteria->addAnd(NightAuditPeer::DATE, $to_date, Criteria::LESS_EQUAL);
      $criteria->add(ContractGradePeer::ID_STATE, 2);

      $criteria->addGroupByColumn(self::ID);

      return self::doSelect($criteria);
   }




} // GradePeer

